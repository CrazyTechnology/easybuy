一、设计模式分为三大类
1.创建型
    工厂方法模式（factory）、单例模式（singleton）、抽象工厂模式（abstract factory）、原型模式、生成器模式
2.结构型
    外观模式（facade）、适配器模式、装饰器模式、代理模式、桥接模式、享元模式、组合模式
3.行为型
    策略模式（strategy）、中介者模式（mediator）、观察者模式、迭代模式、责任链模式、命令模式、备忘录模式、解释器模式

二、设计模式六大原则
1.开闭原则
    对扩展开放、对修改关闭
2.里氏代换原则
    父类出现的地方，子类一定可以出现
3.依赖倒转原则
    依赖抽象，不依赖具体
4.接口隔离原则
    使用多个接口比使用一个好
5.最少知道原则
    一个实体尽量少的与其他实体接触
6.合成复用原则
    尽量使用接口，而不是继承
-----------------------------------------------------------------------
1.策略模式的定义
    定义一系列的算法，把它们一个一个的封装起来，并且可以使它们互相替换。本模式使的算法可以独立于使用它的客户而变化
2.


--------------------------------------------------
三、模式详解
1.策略模式功能
    策略模式的重心不是如何来实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的灵活性和扩展性
2.策略模式和if-else语句
    每个策略算法具体实现的功能就是原来在if-else结构中的具体实现
    策略模式就是把各个平等的具体实现封装到单独的策略实现类了，然后通过上下文来与具体的策略类进行交互
    因此多个if-else可以考虑使用策略模式
3.算法的平等性
    策略模式一个很大的特点就是各个策略算法的平等性。对于一系列的策略算法来说大家的地位都是一样的，正是因为这个平等性，才能使这些算法之间可以相互替换
    策略算法在实现上是相互独立的，不存在依赖
    策略算法是相同行为的不同实现
4.谁来选择具体的策略算法
    在策略模式中，可以在两个地方来进行策略的选择
    一个是客户端，当使用上下文的时候，由客户端来选择具体的策略算法，然后把这个策略算法设置给上下文
    还有一种是客户端不管，由上下文来选择具体的策略算法
5.strategy的实现方式
    通常用接口来定义，但是如果多个算法有多个共同功能的话，可以把strategy实现称为抽象类，然后把多个算法的功能实现到strategy中
6.运行时策略的唯一性
    运行时，每个策略模式在每一个时刻都只能有一个具体的策略实现，虽然可以动态的在不同的策略实现类中切换，但是同时只能使用一个
7.增加新的策略
    先写一个策略算法类来实现新的要求，然后在客户端使用的时候制定使用新的策略算法类就可以。
8.context和strategy的关系
    在策略模式中，通常是上下文使用具体的策略实现对象。反过来，策略实现对象也，可以从上下文获取所需要的数据

---------------------------------------------------------
1.策略模式的优点
    定义一些列算法，实现这些算法之间可以相互替换。
    避免多重条件语句if-else
    更好的扩展性


2.策略模式的缺点
    客户必须了解每种策略的不同，这也暴露了策略的具体实现
    增加了对象数目，由于策略模式把每个具体的策略实现都封装成一个类，如果备选的策略有很多的话，会增加对象的数目
    只适合扁平的算法结构
3.策略模式的本质是：分离算法，选择实现
4.很好的体现了开闭原则、里氏替换原则