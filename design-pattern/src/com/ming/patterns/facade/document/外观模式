一、三大类设计模式
1.创建型：
    工厂方法模式、抽象工厂模式、单例模式、原型模式、生成器模式
2.结构型：
    外观模式（facade）、适配器模式、装饰器模式、代理模式、桥接模式、享元模式、组合模式
3.行为型：
    策略模式、模板方法模式、观察者模式、迭代模式、责任链模式、命令模式、备忘录模式、解释器模式、中介者模式
-------------------------------------------------------------------------------------------------
二、六大设计原则
1.开闭模式
    对扩展开放，对修改关闭
2.里氏代换原则
    基类出现的地方，子类一定可以出现
3.依赖倒转原则
    依赖抽象而不依赖具体
4.接口隔离原则
    使用多个接口，比实现单个接口要好
5.最少知道原则
    一个实体尽量少的与其他实体之间发生相互作用
6.合成复用原则
    尽量使用接口，而不是继承
----------------------------------------------------------------------------------------------------------
三、外观模式
1.外观模式属于结构型，体现了最少知道原则
2.外观模式定义：
    为子系统的一组接口，提供一个一致的界面，facade模式提供了一个高级的接口。外部客户端对这一组的接口的操作可以通过操作facade接口实现
3.外观模式解决问题的思路
    为了使客户端使用更方便 。可以直接调用facade接口，然后facade接口再分别取调用各个模块来实现功能。
    01-facade
        定义子系统的多个模块对外的高层接口，通常需要调用内部多个模块。facade需要知道各个模块，而各个模块不需要知道facade
    02-模块
        接受facade委派，真正实现具体功能。各个模块不知道facade
4.调用示意图

client--调用--->facade{包含ModuleA,MoudleB}     (ModuleA{}  ModuleB{})组成子系统
详情请看下面链接
http://note.youdao.com/noteshare?id=80a2283d9c0b37bece1dd9d4eec9c5c3&sub=E828DF7D86D549C3851B2C07652F7E23

------------------------------------------------------------------------------------------------------
四、外观模式详解
1.外观模式的目的
    并不是给子系统添加新的功能接口，是为了减少外部与子系统各个部分的交互，松散耦合。方便外部更简单的使用子系统
2.外观模式的优缺点
    优点：
        松散耦合、简单易用、划分访问层次
    缺点：
        不合理的 facade会使系统变的复杂
3.外观模式的本质
    封装交互，简化调用
4.何时选用外观模式
    为一个复杂的子系统提供一个简单的接口、构建多层结构的系统、使调用和实现分离
5.外观模式VS中介者模式
    中介者模式主要用来封装多个对象之间的交互，多用在系统内部多个模块之间。
    外观模式封装的单向的交互，是从客户端访问系统的调用，没有系统访问客户端的调用
    中介者模式主要是为了松散多个模块之间的耦合
    外观者模式是为了简化客户端的调用
6.外观模式和单例模式
    一个子系统通常只需要一个外观实例，所以外观模式可以和单例模式组合使用。把facade类实例化成单例，也可以把构造函数私有化，提供一个静态方法
7.外观模式和抽象工厂模式
    ---------------学完抽象工厂后续补充